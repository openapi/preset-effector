// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CLI Should generate accesso api: code 1`] = `
"// @ts-nocheck

// Accesso App Public API. 0.4.0
// ---
// This file is automatically generated by openapi with preset effector-openapi-preset
// Do not edit this file directly. Instead open openapi config file and follow the link in \\"file\\"
import { createEffect } from 'effector';
import * as typed from 'typed-contracts';
import { requestFx } from './request';

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value }

export type GenericErrors =
  | {
      status: 'unexpected';
      error: Error;
    }
  | {
      status: 'unknown_status';
      error: { status: number; body: unknown };
    }
  | {
      status: 'validation_error';
      error: typed.ValidationError;
    };

type ErrorCodes = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 500 | 501 | 502 | 503 | 505;
/**
 * @throws
 */
function parseByStatus<
  Variants extends string,
  Contracts extends Record<number, [Variants, typed.Contract<any>]>,
  Result extends {
    [Code in keyof Contracts]: Contracts[Code] extends [infer Status, typed.Contract<infer T>]
      ? { status: Status; answer: T }
      : never;
  }
>(
  name: string,
  response: { status: number; body?: unknown },
  contracts: Contracts,
): Result[Exclude<keyof Result, ErrorCodes>] {
  const contractObject = contracts[response.status];
  if (!contractObject) {
    throw {
      status: 'unknown_status',
      error: {
        status: response.status,
        body: response.body,
      },
    };
  }
  const [status, contract] = contractObject;
  const answer = contract(name, response.body);
  if (answer instanceof typed.ValidationError) {
    throw { status: 'validation_error', error: answer };
  }
  if (response.status >= 400) {
    throw { status, error: answer };
  }
  return { status, answer } as Result[Exclude<keyof Result, ErrorCodes>];
}

//#endregion prebuilt code/* --- */
//#region oauthToken
export type OauthToken = {
  body: {
    grant_type: \\"authorization_code\\";

    /* This parameter is for the authorization code received from the authorization server which will be in the query string parameter “code” in this request. */
    code: string;

    /* If the redirect URL was included in the initial authorization request,
     * it must be included in the token request as well, and must be identical.
     * Some services support registering multiple redirect URLs, and some require the redirect URL to be specified on each request. */
    redirect_uri: string;
    client_id: string;
    client_secret: string;
  };
};

/* The auth services validated the request and responds with an access token [OAuth2 Example Flow](https://www.oauth.com/oauth2-servers/server-side-apps/example-flow/) */
export const oauthTokenCreated = typed.object({
  access_token: typed.string,
  token_type: typed.union(\\"bearer\\"),

  /* UTC Unix TimeStamp when the access token expires */
  expires_in: typed.number.optional
});
export type OauthTokenDone = {
  status: \\"created\\";
  answer: typed.Get<typeof oauthTokenCreated>;
};

/* When you can't exchange authorization code to access token */
export const oauthTokenBadRequest = typed.object({
  error: typed.union(\\"invalid_request\\", \\"invalid_client\\", \\"invalid_grant\\", \\"invalid_scope\\", \\"unauthorized_client\\", \\"unsupported_grant_type\\")
});

/* Something goes wrong */
export const oauthTokenInternalServerError = typed.nul;
export type OauthTokenFail = {
  status: \\"bad_request\\";
  error: typed.Get<typeof oauthTokenBadRequest>;
} | {
  status: \\"internal_server_error\\";
  error: typed.Get<typeof oauthTokenInternalServerError>;
} | GenericErrors;

/* Exchange the authorization code for an access token */
export const oauthTokenFx = createEffect<OauthToken, OauthTokenDone, OauthTokenFail>({
  async handler({
    body
  }) {
    const name = \\"oauthTokenFx.body\\";
    const response = await requestFx({
      path: \\"/oauth/token\\",
      method: \\"POST\\",
      body
    });
    return parseByStatus(name, response, {
      201: [\\"created\\", oauthTokenCreated],
      400: [\\"bad_request\\", oauthTokenBadRequest],
      500: [\\"internal_server_error\\", oauthTokenInternalServerError]
    });
  }

});
//#endregion oauthToken

/* --- */
//#region viewerGet
export type ViewerGet = {
  header: {
    Authorization: string;
  };
};

/* Get profile of the user */
export const viewerGetOk = typed.object({
  firstName: typed.string,
  lastName: typed.string,
  id: typed.string
});
export type ViewerGetDone = {
  status: \\"ok\\";
  answer: typed.Get<typeof viewerGetOk>;
};

/* Failed to get profile of the user */
export const viewerGetBadRequest = typed.object({
  error: typed.union(\\"invalid_token\\", \\"unauthorized\\")
});

/* Something goes wrong */
export const viewerGetInternalServerError = typed.nul;
export type ViewerGetFail = {
  status: \\"bad_request\\";
  error: typed.Get<typeof viewerGetBadRequest>;
} | {
  status: \\"internal_server_error\\";
  error: typed.Get<typeof viewerGetInternalServerError>;
} | GenericErrors;

/* Get info about viewer by access token */
export const viewerGetFx = createEffect<ViewerGet, ViewerGetDone, ViewerGetFail>({
  async handler({
    header
  }) {
    const name = \\"viewerGetFx.body\\";
    const response = await requestFx({
      path: \\"/viewer.get\\",
      method: \\"POST\\",
      header
    });
    return parseByStatus(name, response, {
      200: [\\"ok\\", viewerGetOk],
      400: [\\"bad_request\\", viewerGetBadRequest],
      500: [\\"internal_server_error\\", viewerGetInternalServerError]
    });
  }

});
//#endregion viewerGet

"
`;

exports[`CLI Should generate accesso api: files 1`] = `
"accesso-app-public-api.ts
"
`;
